name: Argo CD Sync

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to sync"
        required: true
        type: choice
        options:
          - dev
          - prod
      app_name:
        description: "App to sync (leave empty for all apps)"
        required: false
        type: string
  push:
    branches: [main]
    paths:
      - 'domains/platform/**'

jobs:
  sync-argocd:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'dev' }}
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::918859180133:role/GitHubActionsRole
          aws-region: us-east-1
          audience: sts.amazonaws.com

      - name: Install kubectl
        env:
          KUBECTL_VERSION: v1.28.0
        run: |
          curl -sSLo kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Update kubeconfig
        env:
          AWS_REGION: us-east-1
          CLUSTER_NAME: case-dev
        run: |
          echo "Using cluster name: $CLUSTER_NAME"
          aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"
          # Sanity check access
          aws eks describe-cluster --name "$CLUSTER_NAME" --region "$AWS_REGION" >/dev/null
          kubectl cluster-info || (echo "kubectl cannot reach cluster" && exit 1)

      - name: Ensure Argo CD namespace and install (if missing)
        run: |
          kubectl get ns argocd >/dev/null 2>&1 || kubectl create namespace argocd
          # Install Argo CD only if not present (server deployment missing)
          if ! kubectl get deploy argocd-server -n argocd >/dev/null 2>&1; then
            echo "Installing Argo CD..."
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml --validate=false
            echo "Waiting for Argo CD CRDs to be established..."
            # Wait for CRDs by retrying an Application apply dry-run
            for i in {1..20}; do
              if kubectl api-resources | grep -q "applications.argoproj.io"; then
                break
              fi
              echo "Waiting for Application CRD... ($i)"; sleep 6
            done
          else
            echo "Argo CD already installed."
          fi

      - name: Install Argo CD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Apply Argo CD manifests
        run: |
          # Apply root Application (and app-of-apps) with validation disabled to avoid openapi fetch race
          kubectl apply -f domains/platform/argo/ --validate=false

      - name: Wait for Argo CD
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd || true

      - name: Get Argo CD admin password
        id: argocd-password
        run: |
          PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$PASSWORD"
          echo "password=$PASSWORD" >> $GITHUB_OUTPUT

      - name: Login to Argo CD
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 &
          sleep 10
          argocd login localhost:8080 --username admin --password ${{ steps.argocd-password.outputs.password }} --insecure

      - name: Sync specific app
        if: inputs.app_name != ''
        run: |
          argocd app sync ${{ inputs.app_name }} --grpc-web

      - name: Sync all apps
        if: inputs.app_name == ''
        run: |
          argocd app sync -l app.kubernetes.io/instance=case --grpc-web

      - name: Check app health
        env:
          APP_NAME: ${{ inputs.environment == 'prod' && 'case-app-prod' || 'case-app-dev' }}
        run: |
          echo "Validating Argo CD application: $APP_NAME"
          # List apps for visibility
          argocd app list --grpc-web || true
          # Wait for health and sync (fail if not Healthy/Synced in time)
          argocd app wait "$APP_NAME" --health --sync --timeout 600 --grpc-web

      - name: Cleanup port-forward
        if: always()
        run: |
          pkill -f "kubectl port-forward.*argocd-server" || true